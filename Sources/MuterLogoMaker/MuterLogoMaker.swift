import AppKit
import ArgumentParser
import Rainbow

@main
struct MuterLogoMaker: ParsableCommand {

    @Option(
        name: .customLong("output"),
        help: "The path to write the logo Swift file. Will overwrite the supplied file if it exists.",
        transform: URL.init(fileURLWithPath:)
    )
    var outputURL: URL

    func run() throws {
        guard let rtfURL = Bundle.module.url(forResource: "muter_logo", withExtension: "rtf") else {
            throw RTFFileMissing()
        }
        let rtfData = try Data(contentsOf: rtfURL)
        guard let rawLogoString = String(rtfData: rtfData) else {
            throw CouldNotConvertRTFDataToString()
        }

        let escapedLogoString = rawLogoString
            .replacingOccurrences(of: "\u{001B}", with: "\\u{001B}") // escape the escape character

        let fileContents = #"""
            // Generated by https://github.com/muter-mutation-testing/MuterLogoMaker

            let muterLogoForTerminal = """
            \#(escapedLogoString)
            """

            """#

        let fileData = Data(fileContents.utf8)
        try fileData.write(to: outputURL)

        print("Wrote Muter logo code to \(outputURL). Yay!")
    }
}

struct RTFFileMissing: Error {}
struct CouldNotConvertRTFDataToString: Error {}

extension NSColor {
    var asHex: String {
        guard let converted = usingColorSpace(.deviceRGB) else {
            return "#FF00FF" // Magenta
        }

        var red: CGFloat = 0
        var green: CGFloat = 0
        var blue: CGFloat = 0
        converted.getRed(&red, green: &green, blue: &blue, alpha: nil)

        return String(format: "#%02X%02X%02X", Int(red * 0xFF), Int(green * 0xFF), Int(blue * 0xFF))
    }
}

extension String {
    init?(rtfData data: Data) {
        guard let attributedString = NSAttributedString(rtf: data, documentAttributes: nil).map(AttributedString.init(_:)) else {
            return nil
        }

        // Rainbow tries to detect when its output is to a console. We always want to output console-formatted text, so we force Rainbow to use console output. Strictly speaking, we don't have to put it back the way we found it, but it's the polite thing to do and could aid in avoiding future confusion.
        let oldOutputTarget = Rainbow.outputTarget
        defer { Rainbow.outputTarget = oldOutputTarget }
        Rainbow.outputTarget = .console

        let colored = attributedString.runs.map { run in
            let string = String(attributedString[run.range].characters)
            let hexColor = run.foregroundColor?.asHex
            let colored = hexColor.map { string.hex($0) } ?? string
            return colored
        }
        
        self = colored.joined()
    }
}

extension NSAttributedString {
    var fullRange: NSRange {
        NSRange(location: 0, length: length)
    }
}
